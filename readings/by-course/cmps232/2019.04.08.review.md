# Reading Summary 2019-04-08

&middot; by Aldrin Montana

## Co-evolving Tracing and Fault Injection with Box of Pain

> Overall Evaluation

Although this paper claims that co-evolution of tracing and fault-injection should be pursued, my reading of
the paper is that the objective of box of pain is "...to work with arbitrary, unmodified systems by
instrumenting relatively low in the stack." To this end, I believe that while the research described in this
paper seems to still be in early stages, the possibilities and novelty make for quite a good paper.

Section 3 primarily talks about what events are known to be partially ordered or totally ordered, and approaches
for ordering events across system threads. Section 4 details how box of pain traces executions, or runs, of
applications, how previously recorded runs are tracked during a new run, and how the information obtained from
tracing and tracking are used during fault injection. While 4.1 and 4.3 are clearly understandable, I am much
fuzzier on 4.2 and how events in the current run are tracked against previously recorded runs. This is a key aspect
which is assessed by the tests in section 5. Section 6 gives me a sense of how early in progress box of pain is,
and thus makes me feel that this research can lead to many more opportunities. Section 7 is about 20% conclusion,
and about 60% kool-aid of a decent flavor.

I overall very much like this paper, especially given the impact that the results may have on a large and growing
field where tracing and fault-injection could be done without significant upfront investments of time by developers.
Co-evolution of tracing and fault-injection is mentioned, but I see little description of what the co-evolution
looks like compared to tracing and fault-injection designed and implemented in isolation.

> Strong Points:

1. The idea of tracing and performing fault-injection on nodes of a distributed system in between the application and
system levels is moderately novel. It is perhaps of minor to moderate novelty in terms of newness, but seems to be
very novel in terms of implementation or execution. Many other tracing tools appear to interpose at the interface
level between a distributed application and either the network or as events are processed. I believe that many people
have probably thought about this approach, but equally as many people must have either thought it would not be effective
or that they were not sure how to do it.

2. The distribution of unique schedules for a well-known application certainly shows promise that the problem is
tractable in practice.

3. The extension of box of pain from a single machine to many machines does appear at a glance to require only an
engineering effort, which makes the result of this research very exciting. At first, I suspected that fault injection
of interprocess communication (within a machine and across machines) may make fault injection during a run much more
difficult. But on further consideration, it seems that box of pain can do fault injection on sends across a socket,
and never when receiving.

> Weak Points:

1. The evaluation is currently minimal. The evaluation done so far is valuable, though it still only speculates at the correctness of box of pain's approach, it does not confirm nor prove it. 

2.

3.
  
> Questions Raised:

1. What exactly does the co-evolution of tracing and fault-injection look like?
2. Is box of pain still applicable for applications that use a thread pool?
3. Is the result of box of pain's preliminary experiment because of testing a key-value store?
Would an application that is not designed for storage likely to have a similar distribution of unique runs?

> Research Connections:

One of the things our lab is interested in is a "simple" language to specify a more granular concept of when to
inject faults into a distributed system, and how to specify the faults. This type of language aligns very well
with box of pain, which is able to identify the start and end events for tracee applications. While the view of
tracee applications is very much a black box, using start and end events as anchors looks very similar to the use of start and end events visible in a service call graph.
