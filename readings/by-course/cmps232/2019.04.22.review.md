# Reading Summary 2019-04-22

&middot; by Aldrin Montana

## Managing Update Conflicts in Bayou, a Weakly Connected Replicated Storage Systems

> Overall Evaluation

I think this is overall a very good paper. It builds on previous work--session guarantees, anti-entropy--in
distinct, useful ways to build a system, Bayou. The design and work that went into Bayou seems large enough
to warrant many papers, and so I like that this paper has a good scope within which everything is explained
well and provides good insights into the design and implementation of an eventually consistent system.



> Strong Points

1. This system does not explicitly support transactions, but seems to enable applications to define their own
transaction-like context in a flexible manner that begs further insight into the time delays between dependency
checks, conflict checks, and communicated updates.

2. The sessions guarantees provided by the system are at a similar level of abstraction as the mechanisms
provided for applications to specify dependency checks and conflict-merge logic. Having consistency guarantees
that consider all orderings of read and write pairs makes it easier to think of application operations in
imperative or procedural semantics ("If I see this, then I should do X; otherwise, Y"). There is no impedance
mismatch between the features of the system and the development model provided by the system.

3.

> Weak Points

While I like the presentation of dependency checks and merge procedures at a high level, this seems to come
with two particular weak points:
1. As a practitioner, it is not clear what semantics are provided for atomicity, and how to handle the nuances
when a conflict occurs (as with the bank example and simply requiring that at least $100 be in the account).
Should the system block until the writes are resolved via the write log before notifying clients of the operation
status?

2. This approach certainly allows a lot of flexibility, but at the cost of complexity and extra burden on applications.
This may certainly be a reasonable approach, but it can be incredibly difficult and inefficient to require that
applications identify conflicts and write conflict-management code. The downside here being that because *no*
mechanisms are provided by the system to assist application developers, it can lead to a system that is difficult
to build on top of and brittle applications.

3.
  
> Questions Raised



> Research Connections

